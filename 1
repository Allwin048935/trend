import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from binance.client import Client
import telegram
import asyncio
import json
from io import BytesIO
import mplfinance as mpf

# Load config
with open('config.json', 'r') as f:
    config = json.load(f)
    BINANCE_API_KEY = config['binance_api_key']
    BINANCE_API_SECRET = config['binance_api_secret']
    TELEGRAM_TOKEN = config['telegram_token']
    TELEGRAM_CHAT_ID = config['telegram_chat_id']

client = Client(BINANCE_API_KEY, BINANCE_API_SECRET)

async def send_to_telegram(image_buffer):
    bot = telegram.Bot(token=TELEGRAM_TOKEN)
    try:
        await bot.send_photo(chat_id=TELEGRAM_CHAT_ID, photo=image_buffer)
    except telegram.error.BadRequest as e:
        print(f"Telegram error: {e}. Please check your chat_id and bot permissions.")

def get_binance_data(symbol='BTCUSDT', interval='1d', lookback=30):
    klines = client.get_historical_klines(symbol, interval, limit=lookback)
    df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close'] + [None]*7)
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    df = df.set_index('timestamp')[['open', 'high', 'low', 'close']].astype(float)
    df.columns = ['Open', 'High', 'Low', 'Close']  # Capitalize for mpf compatibility
    return df

def calculate_trendlines(data):
    recent_data = data.tail(20)
    x = np.arange(len(recent_data))
    x_extended = np.arange(-len(data)//2, len(data) + len(data)//2)
    
    # Support trendline
    support_indices = recent_data['Low'].nsmallest(2).index
    support_x = [recent_data.index.get_loc(idx) for idx in support_indices]
    support_y = [recent_data['Low'].loc[idx] for idx in support_indices]
    support_slope, support_intercept = np.polyfit(support_x, support_y, 1)
    support_line = support_slope * x_extended + support_intercept
    
    # Resistance trendline
    resist_indices = recent_data['High'].nlargest(2).index
    resist_x = [recent_data.index.get_loc(idx) for idx in resist_indices]
    resist_y = [recent_data['High'].loc[idx] for idx in resist_indices]
    resist_slope, resist_intercept = np.polyfit(resist_x, resist_y, 1)
    resist_line = resist_slope * x_extended + resist_intercept
    
    # Channel type
    if support_slope > 0 and resist_slope > 0:
        channel_type = "Ascending Channel"
    elif support_slope < 0 and resist_slope < 0:
        channel_type = "Descending Channel"
    else:
        channel_type = "Horizontal Channel"
    
    return support_line, resist_line, channel_type, x_extended

async def plot_candles(df, symbol='BTCUSDT'):
    if df.empty:
        return None
    
    # Calculate trendlines
    support_line, resist_line, channel_type, x_extended = calculate_trendlines(df)
    
    # Create extended datetime index
    time_delta = df.index[1] - df.index[0]
    extended_dates = [df.index[0] + time_delta * i for i in x_extended]
    
    # Prepare extended trendline data
    support_df = pd.Series(support_line, index=extended_dates)
    resist_df = pd.Series(resist_line, index=extended_dates)
    
    # Market colors and style
    mc = mpf.make_marketcolors(up='#2fc71e', down='#ed2f1a', inherit=True)
    s = mpf.make_mpf_style(base_mpl_style=['bmh', 'dark_background'], marketcolors=mc, y_on_right=True)
    
    # Plot
    fig, axlist = mpf.plot(
        df,
        figratio=(12, 6),
        type="candle",
        style=s,
        tight_layout=True,
        datetime_format='%Y-%m-%d',
        ylabel="Price ($)",
        addplot=[
            mpf.make_addplot(support_df, color='green', linestyle='--', label='Support'),
            mpf.make_addplot(resist_df, color='red', linestyle='--', label='Resistance')
        ],
        returnfig=True
    )
    
    ax = axlist[0]
    # Set y-axis limits with some padding
    price_range = df['High'].max() - df['Low'].min()
    ax.set_ylim(df['Low'].min() - 0.05 * price_range, df['High'].max() + 0.05 * price_range)
    
    # Customize title and legend
    ax.set_title(f"{symbol} - {channel_type} - {pd.Timestamp.now().strftime('%Y-%m-%d')}", 
                 fontsize=16, style='italic', fontfamily='sans-serif')
    ax.legend(loc='upper left')
    
    # Save to buffer
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    plt.close(fig)
    return buf

async def main():
    # Get data
    data = get_binance_data()
    
    # Plot and send
    buffer = await plot_candles(data)
    if buffer:
        await send_to_telegram(buffer)

if __name__ == "__main__":
    asyncio.run(main())