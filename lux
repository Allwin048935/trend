import requests
import ccxt
import pandas as pd
import matplotlib.pyplot as plt
import mplfinance as mpf
from io import BytesIO
import asyncio
import nest_asyncio
from telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Application, CallbackQueryHandler, ContextTypes
import config  # Import the config module
import ta  # Import ta library
import logging
from datetime import datetime, timedelta
import time
import hmac
import hashlib
from urllib.parse import urlencode
import json
import telegram.error
import numpy as np  # For manual ATR calculation

# Set up logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

file_handler = logging.FileHandler('trading_bot.log')
file_handler.setLevel(logging.INFO)
file_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

console_handler = logging.StreamHandler()
console_handler.setLevel(logging.WARNING)
console_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))

logger.handlers.clear()
logger.addHandler(file_handler)
logger.addHandler(console_handler)

logging.getLogger('urllib3').setLevel(logging.WARNING)
logging.getLogger('ccxt').setLevel(logging.WARNING)

# Time interval and trendline parameters
interval = '5m'  # For trendline calculation
CHECK_INTERVAL = '5m'  # For price cross check
PRIMARY_TRENDLINE_LENGTH = 14  # Matches LuxAlgo's default length
MULT = 1.0  # Slope multiplier from LuxAlgo
CALC_METHOD = 'Atr'  # Options: 'Atr', 'Stdev', 'Linreg'
MAX_STORED_TRENDLINES = 9  # Maximum total stored trendlines

# Pionex API setup
BASE_URL = "https://api.pionex.com"
PIONEX_API_KEY = config.PIONEX_API_KEY
PIONEX_SECRET_KEY = config.PIONEX_SECRET_KEY

# Binance client
binance = ccxt.binance({
    'apiKey': config.BINANCE_API_KEY,
    'secret': config.BINANCE_API_SECRET,
    'enableRateLimit': True,
    'options': {'defaultType': 'future'}
})

# Store trendlines, active orders, and last alert times
stored_trendlines = {}  # Format: {symbol: {'upper': {'lines': [...], 'stored_time': datetime}, 'lower': {...}}}
active_orders = {}
last_alert_times = {}  # Track last alert time per symbol

# Pionex API Functions
def generate_signature(method, path, params, body=None):
    timestamp = str(int(time.time() * 1000))
    query_params = params.copy()
    query_params['timestamp'] = timestamp
    sorted_params = urlencode(sorted(query_params.items()), quote_via=lambda x, *_: x)
    path_url = f"{path}?{sorted_params}"
    string_to_sign = f"{method.upper()}{path_url}"
    if body:
        body_str = json.dumps(body, separators=(',', ':'))
        string_to_sign += body_str
    signature = hmac.new(
        PIONEX_SECRET_KEY.encode('utf-8'),
        string_to_sign.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    return signature, timestamp

def api_request(method, endpoint, params=None, body=None):
    if params is None:
        params = {}
    signature, timestamp = generate_signature(method, endpoint, params, body)
    params['timestamp'] = timestamp
    url = f"{BASE_URL}{endpoint}"
    headers = {
        "PIONEX-KEY": PIONEX_API_KEY,
        "PIONEX-SIGNATURE": signature,
        "Content-Type": "application/json"
    }
    try:
        if method == "GET":
            response = requests.get(url, headers=headers, params=params)
        elif method == "POST":
            response = requests.post(url, headers=headers, params=params, data=json.dumps(body, separators=(',', ':')))
        elif method == "DELETE":
            response = requests.delete(url, headers=headers, params=params, data=json.dumps(body, separators=(',', ':')))
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        logger.error(f"API request failed for {endpoint}: {e}")
        return None

def fetch_pionex_symbols():
    endpoint = "/api/v1/common/symbols"
    params = {}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'symbols' in data['data']:
        symbols = [s['symbol'].replace("_USDT", "USDT") for s in data['data']['symbols'] 
                   if s['quoteCurrency'] == 'USDT' and s['enable']]
        return symbols
    logger.error("Failed to fetch symbols from Pionex - check API key or network")
    return []

def fetch_binance_symbols():
    try:
        markets = binance.load_markets()
        symbols = [symbol.replace('/', '') for symbol in markets.keys() if symbol.endswith('/USDT') and markets[symbol]['active']]
        return symbols
    except Exception as e:
        logger.error(f"Failed to fetch Binance symbols: {e}")
        return []

pionex_symbols = set(fetch_pionex_symbols())
binance_symbols = set(fetch_binance_symbols())
SELECTED_SYMBOLS = list(pionex_symbols.intersection(binance_symbols))

# Pionex API Helper Functions
def get_symbol_info(symbol):
    endpoint = "/api/v1/common/symbols"
    pionex_symbol = symbol.replace("USDT", "_USDT")
    params = {"symbols": pionex_symbol}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'symbols' in data['data'] and data['data']['symbols']:
        return data['data']['symbols'][0]
    logger.error(f"Failed to fetch symbol info for {pionex_symbol}")
    return None

def get_account_balance(symbol):
    endpoint = "/api/v1/account/balances"
    params = {}
    data = api_request("GET", endpoint, params)
    if data and 'data' in data and 'balances' in data['data']:
        base_currency = symbol.replace("USDT", "")
        for balance in data['data']['balances']:
            if balance['coin'] == base_currency:
                return float(balance['free'])
    logger.error(f"Failed to fetch balance for {symbol}")
    return 0.0

def place_market_order(symbol, side, amount_usdt=13.0, quantity=None):
    endpoint = "/api/v1/tr...

Something went wrong, please refresh to reconnect or try again.